<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>圣诞特辑 - 3D光子树</title>
    <link rel="stylesheet" href="style.css" />
    <style>
      /* Specific Styles for this 3D Page */
      body {
        background-color: #000; /* Dark background for particles */
        color: #fff;
        overflow: hidden; /* Prevent scrolling for the 3D experience */
      }

      /* Overwrite Header for this page specifically to look transparent/cool */
      header {
        background-color: rgba(0, 0, 0, 0.5);
        box-shadow: none;
        backdrop-filter: blur(5px);
      }

      .logo,
      .nav-links li a {
        color: white;
      }

      /* 3D Canvas Container */
      #tree-container {
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        z-index: -1; /* Behind header but front of background */
        cursor: grab;
      }

      #tree-container:active {
        cursor: grabbing;
      }

      .instruction-overlay {
        position: absolute;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        pointer-events: none;
        color: rgba(255, 255, 255, 0.7);
      }
    </style>
  </head>
  <body>
    <header>
      <div class="logo">MySpace</div>
      <nav>
        <ul class="nav-links">
          <li><a href="danger.html" class="nav-danger">千万别点！</a></li>
          <li><a href="index.html">首页</a></li>
          <li><a href="blog.html">我的文章</a></li>
          <li><a href="gallery.html" class="active">圣诞特辑</a></li>
          <li class="dropdown">
            <a href="javascript:void(0)"
              >关于站长 <span class="arrow"></span
            ></a>
            <ul class="dropdown-content">
              <li><a href="about.html">个人简介</a></li>
              <li><a href="contact.html">联系我</a></li>
              <li><a href="game.html">找我开黑</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </header>

    <canvas id="tree-container"></canvas>

    <div class="instruction-overlay">
      <h2>Merry Christmas!</h2>
      <p>拖动鼠标旋转视角 | 欣赏绽放的烟花与飘雪</p>
      <p style="font-size: 0.9rem; margin-top: 5px; opacity: 0.8">
        鼠标左右键切换灯带颜色 | 滚轮向上散开成星河，向下聚拢回圣诞树
      </p>
    </div>

    <!-- Background Music -->
    <div style="position: fixed; bottom: 20px; right: 20px; z-index: 100">
      <audio
        controls
        autoplay
        loop
        style="opacity: 0.9; height: 40px; width: 300px"
      >
        <source
          src="music/Jingle Bells (Album Version) - Children's Christmas Favorites.mp3"
          type="audio/mpeg"
        />
        您的浏览器不支持播放音乐。
      </audio>
    </div>

    <script>
      const canvas = document.getElementById("tree-container");
      const ctx = canvas.getContext("2d");

      let width, height;
      let particles = [];
      let fireworks = []; // Fireworks Array

      // Light Strip Global State
      const lightColors = [0, 60, 240, 280, 330]; // Red, Yellow, Blue, Purple, Pink (Removed Green)
      let currentLightColorIndex = 1; // Default Yellow/Warm
      let lightParticlesCount = 0; // To track position along the spiral

      // 3D Variables
      let angleY = 0;
      let angleX = -0.2; // Slight tilt
      let targetAngleY = 0;
      let targetAngleX = -0.2;
      let dragging = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      // Interaction State: Tree <-> Galaxy
      let explosionFactor = 0; // 0 = Tree, 1 = Galaxy
      let targetExplosionFactor = 0;

      // Resize
      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      // Helper: 3D Projection
      function project(x, y, z, angleY, angleX, centerX, centerY) {
        // Rotate Y
        const x1 = x * Math.cos(angleY) - z * Math.sin(angleY);
        const z1 = z * Math.cos(angleY) + x * Math.sin(angleY);

        // Rotate X
        const y1 = y * Math.cos(angleX) - z1 * Math.sin(angleX);
        const z2 = z1 * Math.cos(angleX) + y * Math.sin(angleX);

        const fov = 300;
        const scale = fov / (fov + z2);

        return {
          x: x1 * scale + centerX,
          y: y1 * scale + centerY,
          scale: scale,
          z: z2, // for sorting if needed
        };
      }

      // Particle Class (Tree, Snow, Trunk, Light)
      class Particle {
        constructor(type = "tree", index = 0, total = 0) {
          this.type = type;
          this.index = index; // Used for light strip positioning
          this.total = total;

          // Current Position (for animation)
          this.x = 0;
          this.y = 0;
          this.z = 0;

          // Target Tree Position
          this.treeX = 0;
          this.treeY = 0;
          this.treeZ = 0;

          // Target Galaxy Position
          this.galaxyX = 0;
          this.galaxyY = 0;
          this.galaxyZ = 0;

          this.reset();
        }

        reset() {
          /* --- 1. Define Tree Position --- */
          if (this.type === "tree") {
            // TREE LEAVES
            this.treeY = Math.random() * 400 - 200;
            const maxRadius = ((this.treeY + 200) / 400) * 180 + 10;
            const theta = Math.random() * Math.PI * 2;
            const spiral = this.treeY * 0.1;

            this.treeX = Math.cos(theta + spiral) * maxRadius * Math.random();
            this.treeZ = Math.sin(theta + spiral) * maxRadius * Math.random();

            // Reduced bells: changed from > 0.8 to > 0.95
            this.hue = Math.random() > 0.95 ? 50 : 120 + Math.random() * 40;
            this.lightness = 50 + Math.random() * 30;
            this.size = Math.random() * 2 + 1;
            this.alpha = Math.random() * 0.5 + 0.5;
            this.speedY = 0;
          } else if (this.type === "trunk") {
            // TREE TRUNK
            this.treeY = Math.random() * 100 + 200;
            const radius = Math.random() * 25;
            const theta = Math.random() * Math.PI * 2;
            this.treeX = Math.cos(theta) * radius;
            this.treeZ = Math.sin(theta) * radius;
            this.hue = 30; // Brown
            this.lightness = 30 + Math.random() * 20;
            this.size = Math.random() * 2 + 1;
            this.alpha = 0.8;
            this.speedY = 0;
          } else if (this.type === "snow") {
            // FALLING SNOW (Dynamic, handled in update, but needs intial pos)
            this.treeX = Math.random() * width - width / 2;
            this.treeY = Math.random() * height - height / 2;
            this.treeZ = Math.random() * 800 - 400;
            this.hue = 200;
            this.lightness = 100;
            this.size = Math.random() * 3 + 2;
            this.alpha = Math.random() * 0.5 + 0.5;
            this.speedY = Math.random() * 1.5 + 0.5;
          } else if (this.type === "light") {
            // LIGHT STRIP (Spiral)
            // Normalized position t from 0 (bottom) to 1 (top)
            // Actually y is -200 (top) to 200 (bottom).
            // Let's wind from bottom (200) to top (-200).
            const t = this.index / this.total;
            this.treeY = 200 - t * 400; // 200 -> -200

            // Radius decreases as we go up
            const maxRadius = ((this.treeY + 200) / 400) * 180 + 10;
            // Place lights INSIDE the surface foliage slightly (0.8 instead of 1.05)
            // This makes it look like it's wrapped around the branches, not floating
            const r = maxRadius * 0.9;

            // Spiral Angle: 6 full rotations (6 * 2PI)
            const theta = t * Math.PI * 2 * 6;

            this.treeX = Math.cos(theta) * r;
            this.treeZ = Math.sin(theta) * r;

            this.lightness = 60;
            this.size = 3.5; // Bigger than leaves
            this.alpha = 1;
            this.speedY = 0;
          }
          /* --- 2. Define Galaxy Position (Spherical / Spiral Cloud) --- */
          // Create a beautiful spherical distribution with some spiral arm tendency
          const r = 400 + Math.random() * 400; // Large radius
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          this.galaxyX = r * Math.sin(phi) * Math.cos(theta);
          this.galaxyY = r * Math.sin(phi) * Math.sin(theta);
          this.galaxyZ = r * Math.cos(phi);

          // Initialize current position to tree
          this.x = this.treeX;
          this.y = this.treeY;
          this.z = this.treeZ;

          this.sparkleSpeed = Math.random() * 0.05 + 0.01;
        }

        update() {
          // 1. Snow Physics (Only when close to Tree Mode)
          if (this.type === "snow" && explosionFactor < 0.5) {
            this.treeY += this.speedY; // Fall down logic applies to tree Coordinates
            if (this.treeY > 400) {
              this.treeY = -400;
            }
          }

          // 2. Sparkle
          if (this.type !== "snow") {
            this.alpha += this.sparkleSpeed;
            if (this.alpha > 1 || this.alpha < 0.3) this.sparkleSpeed *= -1;
          }

          // 3. INTERPOLATION: Tree <-> Galaxy
          // Ease the transition
          // Position = TreePos * (1 - factor) + GalaxyPos * factor

          // For snow, if we are in Galaxy mode, let it drift to galaxy position too?
          // Or keep falling? Let's make EVERYTHING explode.

          this.x =
            this.treeX * (1 - explosionFactor) + this.galaxyX * explosionFactor;
          this.y =
            this.treeY * (1 - explosionFactor) + this.galaxyY * explosionFactor;
          this.z =
            this.treeZ * (1 - explosionFactor) + this.galaxyZ * explosionFactor;

          // Fade out trunk in galaxy mode?
          if (this.type === "trunk" && explosionFactor > 0.5) {
            this.alpha *= 1 - explosionFactor;
          }
        }

        draw(ctx, centerX, centerY, angleY, angleX) {
          // If fully invisible, skip
          if (this.alpha <= 0.01) return;

          const p = project(
            this.x,
            this.y,
            this.z,
            angleY,
            angleX,
            centerX,
            centerY
          );
          if (p.scale > 0) {
            let color;
            if (this.type === "light") {
              const hue = lightColors[currentLightColorIndex];
              // In Galaxy mode, maybe lights become random stars? Keep color for continuity
              color = `hsla(${hue}, 100%, 60%, ${this.alpha})`;
              // Add glow for lights
              ctx.shadowBlur = 10;
              ctx.shadowColor = `hsla(${hue}, 100%, 60%, 1)`;
            } else {
              color = `hsla(${this.hue}, 100%, ${this.lightness}%, ${this.alpha})`;
              ctx.shadowBlur = 0;
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, this.size * p.scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0; // Reset
          }
        }
      }

      // Firework Class
      class Firework {
        constructor() {
          this.reset();
        }

        reset() {
          // Spawn in the background "Skybox" area
          // WE WANT TWO SIDES: Avoid the center (-300 to 300) so tree is clear
          const side = Math.random() > 0.5 ? 1 : -1;
          // Spawn range: +/- [400, 900]
          this.x = side * (400 + Math.random() * 500);

          // Z is always positive (far away into the screen)
          this.z = 600 + Math.random() * 500;

          this.y = 800; // Start far below
          this.targetY = -300 - Math.random() * 400; // Explode higher relative to tree

          this.speed = 8 + Math.random() * 4;

          // Warm Colors: Red (0) to Yellow (60)
          this.hue = Math.random() * 50;

          this.state = "rising";
          this.particles = [];
          this.isDead = false;
        }

        update() {
          if (this.state === "rising") {
            this.y -= this.speed;
            this.speed *= 0.99;

            if (this.y < this.targetY || this.speed < 1) {
              this.explode();
            }
          } else {
            // Exploded
            let aliveCount = 0;
            for (let i = 0; i < this.particles.length; i++) {
              const p = this.particles[i];
              if (p.alpha > 0) {
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                p.vy += 0.05; // Lower gravity
                p.alpha -= 0.008; // Long life
                aliveCount++;
              }
            }
            if (aliveCount === 0) {
              this.isDead = true;
            }
          }
        }

        explode() {
          this.state = "exploded";
          const count = 120; // More particles
          for (let i = 0; i < count; i++) {
            const speed = Math.random() * 6 + 2;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;

            this.particles.push({
              x: this.x,
              y: this.y,
              z: this.z,
              vx: speed * Math.sin(phi) * Math.cos(theta),
              vy: speed * Math.sin(phi) * Math.sin(theta),
              vz: speed * Math.cos(phi),
              alpha: 1,
              hue: this.hue + Math.random() * 20 - 10,
              // Larger particles: Random 3px to 5px (fluffy)
              size: Math.random() * 2 + 3,
            });
          }
        }

        // Special Draw: Ignores AngleY (World Spin) to stay in background background
        draw(ctx, centerX, centerY, angleX) {
          // Lock AngleY to 0 so it doesn't spin around the tree
          // But keep AngleX so it tilts with the camera
          const fixedAngleY = 0;

          if (this.state === "rising") {
            const p = project(
              this.x,
              this.y,
              this.z,
              fixedAngleY,
              angleX,
              centerX,
              centerY
            );
            if (p.scale > 0) {
              ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
              ctx.beginPath();
              ctx.arc(p.x, p.y, 5 * p.scale, 0, Math.PI * 2);
              ctx.fill();
            }
          } else {
            this.particles.forEach((p) => {
              if (p.alpha > 0) {
                const pos = project(
                  p.x,
                  p.y,
                  p.z,
                  fixedAngleY,
                  angleX,
                  centerX,
                  centerY
                );
                if (pos.scale > 0) {
                  ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.alpha})`;
                  ctx.beginPath();
                  ctx.arc(pos.x, pos.y, p.size * pos.scale, 0, Math.PI * 2);
                  ctx.fill();
                }
              }
            });
          }
        }
      }

      // Initialize Particles
      // Leaves
      for (let i = 0; i < 1500; i++) {
        particles.push(new Particle("tree"));
      }
      // Trunk
      for (let i = 0; i < 400; i++) {
        particles.push(new Particle("trunk"));
      }
      // Snow
      for (let i = 0; i < 500; i++) {
        particles.push(new Particle("snow"));
      }
      // Lights
      const totalLights = 100;
      for (let i = 0; i < totalLights; i++) {
        particles.push(new Particle("light", i, totalLights));
      }

      // Star on Top
      const star = { x: 0, y: -210, z: 0, hue: 60 };

      function draw() {
        ctx.clearRect(0, 0, width, height);

        // Interaction Rotation
        angleY += (targetAngleY - angleY) * 0.1;
        angleX += (targetAngleX - angleX) * 0.1;

        // Explosion Interaction (Smooth Transition)
        explosionFactor += (targetExplosionFactor - explosionFactor) * 0.05;

        if (!dragging) {
          targetAngleY += 0.005;
        }

        // Lower Frequency: approx 1 every 2.5 seconds (at 60fps)
        if (Math.random() < 0.007) {
          fireworks.push(new Firework());
        }

        const centerX = width / 2;
        const centerY = height / 2;

        // 1. Draw Fireworks FIRST (Background Layer)
        // They ignore angleY logic inside their draw method
        for (let i = fireworks.length - 1; i >= 0; i--) {
          const fw = fireworks[i];
          fw.update();
          fw.draw(ctx, centerX, centerY, angleX); // Note: Passing angleX only effectively
          if (fw.isDead) {
            fireworks.splice(i, 1);
          }
        }

        // 2. Draw Tree & Snow & Lights (Foreground Layer)
        // Standard depth sort often helps tree look correct
        particles.sort((a, b) => {
          // Rough depth projection for sorting
          // We care about Transformed Z.
          // To save CPU, we use pre-calced rough depths or just y/z approximation
          // For a dense particle cloud, simple painter's algo without sort (since we draw fireworks first) is usually tolerable
          // But let's try a quick sort if performance allows
          // (Omitted strict sort for perf, relying on 'fireworks first' for big layer separation)
          return 0;
        });

        particles.forEach((p) => {
          p.update();
          p.draw(ctx, centerX, centerY, angleY, angleX);
        });

        // Draw Star (Scale down in Galaxy Mode)
        if (explosionFactor < 0.8) {
          const starPos = project(
            star.x,
            star.y,
            star.z,
            angleY,
            angleX,
            centerX,
            centerY
          );
          if (starPos.scale > 0) {
            const fade = 1 - explosionFactor;
            ctx.fillStyle = `rgba(255, 215, 0, ${fade})`; // Gold with Fade
            ctx.beginPath();
            ctx.arc(
              starPos.x,
              starPos.y,
              10 * starPos.scale * fade,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 20;
            ctx.shadowColor = `rgba(255, 215, 0, ${fade})`;
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }

        requestAnimationFrame(draw);
      }

      // Scroll Interaction for Galaxy Explosion
      window.addEventListener("wheel", (e) => {
        // Scroll Up (deltaY < 0) -> Explode
        // Scroll Down (deltaY > 0) -> Implode
        if (e.deltaY < 0) {
          targetExplosionFactor += 0.1;
        } else {
          targetExplosionFactor -= 0.1;
        }
        // Clamp
        if (targetExplosionFactor < 0) targetExplosionFactor = 0;
        if (targetExplosionFactor > 1) targetExplosionFactor = 1;
      });

      // Mouse Interactions
      canvas.addEventListener("mousedown", (e) => {
        // Light Color Interaction
        if (e.button === 0) {
          // Left Click: Next Color
          currentLightColorIndex =
            (currentLightColorIndex + 1) % lightColors.length;
        } else if (e.button === 2) {
          // Right Click: Prev Color
          currentLightColorIndex =
            (currentLightColorIndex - 1 + lightColors.length) %
            lightColors.length;
        }

        dragging = true;
      });

      // Prevent Context Menu on Right Click
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      window.addEventListener("mouseup", () => {
        dragging = false;
      });

      window.addEventListener("mousemove", (e) => {
        if (dragging) {
          const deltaX = e.clientX - lastMouseX;
          const deltaY = e.clientY - lastMouseY;

          targetAngleY += deltaX * 0.01;
          targetAngleX += deltaY * 0.01;

          // CLAMP AngleX to prevent inversion
          // Range -1.5 (looking down from top-ish) to 1.5 (looking up from bottom)
          // Actually, PI/2 is 1.57. So 1.4 is safe.
          const limit = 1.4;
          if (targetAngleX > limit) targetAngleX = limit;
          if (targetAngleX < -limit) targetAngleX = -limit;

          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        } else {
          // Update last position even if not dragging to prevent jump on click
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
      });
      // Initial set to avoid 0 jump
      window.addEventListener(
        "mousemove",
        (e) => {
          if (!dragging) {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
          }
        },
        { once: true }
      );

      draw();
    </script>
  </body>
</html>
